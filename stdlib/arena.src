#import "memory.src";
using memory;

// Can overflow, be careful
divide_round_up :: (left: $T, right: T) -> T {
    return (left + right - 1) / right;
}

Arena :: struct {
    memory: *void,
    size: usize,
    current_offset: usize
}

create_arena :: (size: usize) -> (bool, Arena) {
    if size == 0 {
        return false, undef;
    }

    memory := map_virtual_memory(size);

    return true, {
        memory = memory,
        size = size,
        current_offset = 0
    };
}

destroy_arena :: (arena: Arena) {
    unmap_virtual_memory(arena.memory, arena.size);
}

reset_arena :: (arena: *Arena) {
    arena.current_offset = 0;
}

allocate :: (arena: *Arena, size: usize) -> *void {
    if size == 0 {
        return 0;
    }

    total_size := divide_round_up(size, largest_alignment) * largest_alignment;

    if arena.current_offset + total_size > arena.size {
        return 0;
    }

    base_address := arena.memory as usize + arena.current_offset;

    arena.current_offset += total_size;

    return base_address as *void;
}