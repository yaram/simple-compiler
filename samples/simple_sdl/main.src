#import "stdlib/memory.src";
using memory;

#import "stdlib/expanding_arena.src";
using expanding_arena;

#import "sdl.src";

using sdl;

using SDL_EventType;
using SDL_Keycode;
using SDL_WindowEventID;

prng :: (state: *u32) -> u32 {
    x := @state;

    x = x + (x << 13);
    x = x + (x >> 17);
    x = x + (x << 5);

    @state = x;

    return x;
}

rand_uniform :: (state: *u32) -> f32 {
    return (prng(state) % 0x10000) as f32 / 0x10000;
}

Point :: struct {
    x: f32,
    y: f32,
    velocity_x: f32,
    velocity_y: f32,
    mass: f32
}

Node :: struct {
    children: [2][2]*void,
    mass: f32,
    centre_of_mass_x: f32,
    centre_of_mass_y: f32
}

create_node :: () -> Node {
    return {
        children = { { 0 as *void, 0 }, { 0 as *void, 0 } },
        mass = 0,
        centre_of_mass_x = 0,
        centre_of_mass_y = 0
    };
}

build_tree :: (arena: *ExpandingArena, point: Point, node: *Node, x: f32, y: f32, width: f32, height: f32) {
    quadrant_width := width / 2;
    quadrant_height := height / 2;

    for 0..1 as usize {
        quadrant_index_y := it;

        quadrant_y := y + quadrant_index_y as f32 * quadrant_height;

        for 0..1 as usize {
            quadrant_index_x := it;

            quadrant_x := x + quadrant_index_x as f32 * quadrant_width;

            if
                (point.x > quadrant_x || point.x == quadrant_x) && point.x < quadrant_x + quadrant_width &&
                (point.y > quadrant_y || point.y == quadrant_y) && point.y < quadrant_y + quadrant_height
            {
                quadrant_node := node.children[quadrant_index_y][quadrant_index_x] as *Node;

                if quadrant_node == 0 {
                    new_quadrant_node := allocate(arena, size_of(Node)) as *Node;
                    @new_quadrant_node = create_node();

                    node.children[quadrant_index_y][quadrant_index_x] = new_quadrant_node as *void;
                } else {
                    build_tree(arena, point, quadrant_node, quadrant_x, quadrant_y, quadrant_width, quadrant_height);
                }

                return;
            }
        }
    }
}

fill_tree :: (arena: *ExpandingArena, point: Point, node: *Node, x: f32, y: f32, width: f32, height: f32) {
    node.mass += point.mass;
    node.centre_of_mass_x += point.x * point.mass;
    node.centre_of_mass_y += point.y * point.mass;

    quadrant_width := width / 2;
    quadrant_height := height / 2;

    for 0..1 as usize {
        quadrant_index_y := it;

        quadrant_y := y + quadrant_index_y as f32 * quadrant_height;

        for 0..1 as usize {
            quadrant_index_x := it;

            quadrant_x := x + quadrant_index_x as f32 * quadrant_width;

            if
                (point.x > quadrant_x || point.x == quadrant_x) && point.x < quadrant_x + quadrant_width &&
                (point.y > quadrant_y || point.y == quadrant_y) && point.y < quadrant_y + quadrant_height
            {
                quadrant_node := node.children[quadrant_index_y][quadrant_index_x] as *Node;

                if quadrant_node != 0 {
                    fill_tree(arena, point, quadrant_node, quadrant_x, quadrant_y, quadrant_width, quadrant_height);
                }

                return;
            }
        }
    }
}

finalise_tree :: (node: *Node) {
    node.centre_of_mass_x /= node.mass;
    node.centre_of_mass_y /= node.mass;

    for 0..1 as usize {
        quadrant_index_y := it;

        for 0..1 as usize {
            quadrant_index_x := it;

            quadrant_node := node.children[quadrant_index_y][quadrant_index_x] as *Node;

            if quadrant_node != 0 {
                finalise_tree(quadrant_node);
            }
        }
    }
}

calculate_force :: (point: Point, node: *Node, x: f32, y: f32, width: f32, height: f32) -> (f32, f32) {
    quadrant_width := width / 2;
    quadrant_height := height / 2;

    average_size := (quadrant_width + quadrant_height) / 2;

    force_x: f32 = 0;
    force_y: f32 = 0;
    is_leaf := true;
    for 0..1 as usize {
        quadrant_index_y := it;

        quadrant_y := y + quadrant_index_y as f32 * quadrant_height;

        for 0..1 as usize {
            quadrant_index_x := it;

            quadrant_x := x + quadrant_index_x as f32 * quadrant_width;

            quadrant_node := node.children[quadrant_index_y][quadrant_index_x] as *Node;

            if quadrant_node != 0 {
                is_leaf = false;

                difference_x := quadrant_node.centre_of_mass_x - point.x;
                difference_y := quadrant_node.centre_of_mass_y - point.y;

                distance := sqrt(difference_x * difference_x + difference_y * difference_y);

                if distance > 0.0001 {
                    metric := average_size / distance;

                    theta :: 1.0;

                    if metric < theta {
                        force := point.mass * quadrant_node.mass / distance;

                        direction_x := difference_x / distance;
                        direction_y := difference_y / distance;

                        force_x += force * direction_x;
                        force_y += force * direction_y;
                    } else {
                        quadrant_force_x, quadrant_force_y := calculate_force(
                            point,
                            quadrant_node,
                            quadrant_x,
                            quadrant_y,
                            quadrant_width,
                            quadrant_height
                        );

                        force_x += quadrant_force_x;
                        force_y += quadrant_force_y;
                    }
                }
            }
        }
    }

    if is_leaf {
        difference_x := node.centre_of_mass_x - point.x;
        difference_y := node.centre_of_mass_y - point.y;

        distance := sqrt(difference_x * difference_x + difference_y * difference_y);

        force := point.mass * node.mass / distance;

        direction_x := difference_x / distance;
        direction_y := difference_y / distance;

        force_x += force * direction_x;
        force_y += force * direction_y;
    }

    return force_x, force_y;
}

draw_graph :: (
    renderer: *SDL_Renderer,
    window_width: i32,
    window_height: i32,
    node: *Node,
    x: f32,
    y: f32,
    width: f32,
    height: f32
) {
    SDL_SetRenderDrawColor(renderer, 0x80, 0, 0, 0xFF);

    rect1: SDL_Rect = {
        x = (x * window_width as f32) as i32,
        y = (y * window_height as f32) as i32,
        w = (width * window_width as f32) as i32,
        h = (height * window_height as f32) as i32
    };
    SDL_RenderDrawRect(renderer, *rect1);

    SDL_SetRenderDrawColor(renderer, 0, 0, 0xFF, 0xFF);

    rect2: SDL_Rect = {
        x = (node.centre_of_mass_x * window_width as f32) as i32,
        y = (node.centre_of_mass_y * window_height as f32) as i32,
        w = 1,
        h = 1
    };
    SDL_RenderFillRect(renderer, *rect2);

    quadrant_width := width / 2;
    quadrant_height := height / 2;

    for 0..1 as usize {
        quadrant_index_y := it;

        quadrant_y := y + quadrant_index_y as f32 * quadrant_height;

        for 0..1 as usize {
            quadrant_index_x := it;

            quadrant_x := x + quadrant_index_x as f32 * quadrant_width;

            quadrant_node := node.children[quadrant_index_y][quadrant_index_x] as *Node;

            if quadrant_node != 0 {
                draw_graph(renderer, window_width, window_height, quadrant_node, quadrant_x, quadrant_y, quadrant_width, quadrant_height);
            }
        }
    }
}

main :: () -> i32 {
    if SDL_Init(SDL_INIT_VIDEO) != 0 {
        return 1;
    }

    window := SDL_CreateWindow(
        globalify("Test\0").pointer,
        SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED,
        720,
        720,
        SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE
    );
    if window == 0 {
        return 1;
    }

    renderer := SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if renderer == 0 {
        return 1;
    }

    rand_state: u32 = 1;

    point_count :: 1024 * 4;

    points: []Point = {
        length = point_count,
        pointer = map_virtual_memory(point_count * size_of(Point)) as *Point
    };

    next_points: []Point = {
        length = point_count,
        pointer = map_virtual_memory(point_count * size_of(Point)) as *Point
    };

    for 0..points.length - 1 {
        points[it] = {
            x = rand_uniform(*rand_state),
            y = rand_uniform(*rand_state),
            velocity_x = 0,
            velocity_y = 0,
            mass = 1
        };
    }

    arena := create_expanding_arena();

    running := true;
    while running {
        event: SDL_Event = undef;

        while SDL_PollEvent(*event) != 0 {
            if event.type == SDL_QUIT {
                running = false;
            } else if event.type == SDL_WINDOWEVENT {
                window_event := event.body.window;

                if window_event.event == SDL_WINDOWEVENT_CLOSE {
                    running = false;
                }
            }
        }

        // Build Barnes-Hut graph

        root_node := create_node();

        for 0..points.length - 1 {
            build_tree(*arena, points[it], *root_node, 0, 0, 1, 1);
        }

        for 0..points.length - 1 {
            fill_tree(*arena, points[it], *root_node, 0, 0, 1, 1);
        }

        finalise_tree(*root_node);

        timestep :: 0.0001;

        for 0..points.length - 1 {
            point := *points[it];

            force_x, force_y := calculate_force(points[it], *root_node, 0, 0, 1, 1);

            next_point := *next_points[it];

            next_point.velocity_x = point.velocity_x + timestep * force_x / point.mass;
            next_point.velocity_y = point.velocity_y + timestep * force_y / point.mass;

            next_point.x = point.x + timestep * next_point.velocity_x;
            next_point.y = point.y + timestep * next_point.velocity_y;

            next_point.mass = point.mass;

            if next_point.x < 0 {
                next_point.x = 0;
                next_point.velocity_x = 0;
            } else if next_point.x > 1 {
                next_point.x = 1;
                next_point.velocity_x = 0;
            }

            if next_point.y < 0 {
                next_point.y = 0;
                next_point.velocity_y = 0;
            } else if next_point.y > 1 {
                next_point.y = 1;
                next_point.velocity_y = 0;
            }
        }

        reset_expanding_arena(*arena);

        temp := points;
        points = next_points;
        next_points = temp;

        window_width: i32 = undef;
        window_height: i32 = undef;
        SDL_GetWindowSize(window, *window_width, *window_height);

        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0xFF);
        SDL_RenderClear(renderer);

        draw_graph(renderer, window_width, window_height, *root_node, 0, 0, 1, 1);

        SDL_SetRenderDrawColor(renderer, 0xFF, 0xFF, 0xFF, 0xFF);

        for 0..points.length - 1 {
            rect: SDL_Rect = {
                x = (points[it].x * window_width as f32) as i32,
                y = (points[it].y * window_height as f32) as i32,
                w = 1,
                h = 1
            };
            SDL_RenderFillRect(renderer, *rect);
        }

        SDL_RenderPresent(renderer);
    }

    return 0;
}